const uint local_x = 32;
const uint local_y = 32;
const uint group_size = local_x * local_y;
layout (local_size_x = local_x, local_size_y = local_y, local_size_z = 1) in;

struct Particle { vec2 front, back; };
layout (std430, binding = 0) buffer SSBO_particles { Particle particles[]; };

struct Vortex {
	vec2 position;
	float force;
	float pad0;
};

struct Pusher {
	vec2 position;
	float force;
	float pad0;
};

layout (std140, binding = 0) uniform UBO_actors {
	Vortex vortices[16];
	Pusher pushers[16];
};

layout (location = 0) uniform uint current_tick;
layout (location = 1) uniform uint particle_lifetime;
layout (location = 10) uniform uint num_vortices;
layout (location = 11) uniform uint num_pushers;

#define MAX_VELOCITY 5
vec2 velocity_at (vec2 p)
{
	vec2 vel = vec2(0);

	// Linear falloff of force
	for (uint i = 0; i < num_vortices; i++) {
		vec2 r = p - vortices[i].position;
		vel += vortices[i].force * vec2(-r.y, r.x) / dot(r, r);
	}
	for (uint i = 0; i < num_pushers; i++) {
		vec2 r = p - pushers[i].position;
		vel += pushers[i].force * r / dot(r, r);
	}

	float vel2 = dot(vel,vel);
	if (vel2 > MAX_VELOCITY * MAX_VELOCITY)
		vel *= MAX_VELOCITY / sqrt(vel2);

	return vel;
}

void main ()
{
	uint wg_index = gl_WorkGroupID.y * gl_NumWorkGroups.x + gl_WorkGroupID.x;
	uint id = wg_index * group_size + gl_LocalInvocationIndex;

	uint random = 1664525 * id + 1013904223;
	random ^= (random << 13);
	random ^= (random >> 17);
	random ^= (random << 5);

	// Reset the particle to its initial position every so often,
	// with a pseudo-random phase shift for each particle
	vec2 old_position = ((current_tick - random) % particle_lifetime == 0)
		? vec2(gl_GlobalInvocationID.xy)
		: particles[id].front;

	particles[id].front = old_position + velocity_at(old_position);
	particles[id].back = old_position;
}
